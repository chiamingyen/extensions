%%
%% This is file `aipauth4-1long.bst',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% merlin.mbs  (with options: `head,ay,nat,lang,pres,pres-bf,vonx,nm-revf,nmft,nmft-def,fnm-def,nmfted,nmand-rm,lab,lab-def,and-rm,blkyear,yr-par,date-nil-x,tit-qq,inproceedings-chapter,article-title-o,inproceedings-chapter,article-booktitle,article-series,jttl-rm,journal-address,book-bt,thesis-title-o,techreport-institution-par,vol-bf,vnum-x,volp-com,book-editor-booktitle,inbook-editor-booktitle,bookaddress,num-xser,number-cap,chapter-cap,series-number,numser-booktitle,ser-vol,ser-rm,volume-cap,ser-ed,jnm-x,pg-bk,book-chapter-pages,pub-date,ay-empty-pub-parens-x,pre-pub,pre-edn,pre-pub,pre-edn,isbn,issn,doi-link,doi,edby,blk-com,fin-endbibitem,pp,ed,abr,ednx,ord,jabr,etal-it,revdata,eprint,url,url-blk,translation,SLACcitation,numpages-x,url,url-prefix-x,bibinfo,bibfield,nfss,,{}')
%% physjour.mbs  (with options: `ay,nat,lang,pres,pres-bf,vonx,nm-revf,nmft,nmft-def,fnm-def,nmfted,nmand-rm,lab,lab-def,and-rm,blkyear,yr-par,date-nil-x,tit-qq,inproceedings-chapter,article-title-o,inproceedings-chapter,article-booktitle,article-series,jttl-rm,journal-address,book-bt,thesis-title-o,techreport-institution-par,vol-bf,vnum-x,volp-com,book-editor-booktitle,inbook-editor-booktitle,bookaddress,num-xser,number-cap,chapter-cap,series-number,numser-booktitle,ser-vol,ser-rm,volume-cap,ser-ed,jnm-x,pg-bk,book-chapter-pages,pub-date,ay-empty-pub-parens-x,pre-pub,pre-edn,pre-pub,pre-edn,isbn,issn,doi-link,doi,edby,blk-com,fin-endbibitem,pp,ed,abr,ednx,ord,jabr,etal-it,revdata,eprint,url,url-blk,translation,SLACcitation,numpages-x,url,url-prefix-x,bibinfo,bibfield,nfss,,{}')
%% geojour.mbs  (with options: `ay,nat,lang,pres,pres-bf,vonx,nm-revf,nmft,nmft-def,fnm-def,nmfted,nmand-rm,lab,lab-def,and-rm,blkyear,yr-par,date-nil-x,tit-qq,inproceedings-chapter,article-title-o,inproceedings-chapter,article-booktitle,article-series,jttl-rm,journal-address,book-bt,thesis-title-o,techreport-institution-par,vol-bf,vnum-x,volp-com,book-editor-booktitle,inbook-editor-booktitle,bookaddress,num-xser,number-cap,chapter-cap,series-number,numser-booktitle,ser-vol,ser-rm,volume-cap,ser-ed,jnm-x,pg-bk,book-chapter-pages,pub-date,ay-empty-pub-parens-x,pre-pub,pre-edn,pre-pub,pre-edn,isbn,issn,doi-link,doi,edby,blk-com,fin-endbibitem,pp,ed,abr,ednx,ord,jabr,etal-it,revdata,eprint,url,url-blk,translation,SLACcitation,numpages-x,url,url-prefix-x,bibinfo,bibfield,nfss,,{}')
%% photjour.mbs  (with options: `ay,nat,lang,pres,pres-bf,vonx,nm-revf,nmft,nmft-def,fnm-def,nmfted,nmand-rm,lab,lab-def,and-rm,blkyear,yr-par,date-nil-x,tit-qq,inproceedings-chapter,article-title-o,inproceedings-chapter,article-booktitle,article-series,jttl-rm,journal-address,book-bt,thesis-title-o,techreport-institution-par,vol-bf,vnum-x,volp-com,book-editor-booktitle,inbook-editor-booktitle,bookaddress,num-xser,number-cap,chapter-cap,series-number,numser-booktitle,ser-vol,ser-rm,volume-cap,ser-ed,jnm-x,pg-bk,book-chapter-pages,pub-date,ay-empty-pub-parens-x,pre-pub,pre-edn,pre-pub,pre-edn,isbn,issn,doi-link,doi,edby,blk-com,fin-endbibitem,pp,ed,abr,ednx,ord,jabr,etal-it,revdata,eprint,url,url-blk,translation,SLACcitation,numpages-x,url,url-prefix-x,bibinfo,bibfield,nfss,,{}')
%% merlin.mbs  (with options: `tail,ay,nat,lang,pres,pres-bf,vonx,nm-revf,nmft,nmft-def,fnm-def,nmfted,nmand-rm,lab,lab-def,and-rm,blkyear,yr-par,date-nil-x,tit-qq,inproceedings-chapter,article-title-o,inproceedings-chapter,article-booktitle,article-series,jttl-rm,journal-address,book-bt,thesis-title-o,techreport-institution-par,vol-bf,vnum-x,volp-com,book-editor-booktitle,inbook-editor-booktitle,bookaddress,num-xser,number-cap,chapter-cap,series-number,numser-booktitle,ser-vol,ser-rm,volume-cap,ser-ed,jnm-x,pg-bk,book-chapter-pages,pub-date,ay-empty-pub-parens-x,pre-pub,pre-edn,pre-pub,pre-edn,isbn,issn,doi-link,doi,edby,blk-com,fin-endbibitem,pp,ed,abr,ednx,ord,jabr,etal-it,revdata,eprint,url,url-blk,translation,SLACcitation,numpages-x,url,url-prefix-x,bibinfo,bibfield,nfss,,{}')
%% ----------------------------------------
%% *** REVTeX-compatible aipauth4-1long.bst 2009-10-08 ***
%% 
%% Copyright 1994-2007 Patrick W Daly
 % ===============================================================
 % IMPORTANT NOTICE:
 % This bibliographic style (bst) file has been generated from one or
 % more master bibliographic style (mbs) files, listed above.
 %
 % This generated file can be redistributed and/or modified under the terms
 % of the LaTeX Project Public License Distributed from CTAN
 % archives in directory macros/latex/base/lppl.txt; either
 % version 1 of the License, or any later version.
 % ===============================================================
 % Name and version information of the main mbs file:
 % \ProvidesFile{merlin.mbs}[2008/01/17 4.21 (PWD, AO, DPC)]
 %   For use with BibTeX version 0.99a or later
 %-------------------------------------------------------------------
 % This bibliography style file is intended for texts in ENGLISH
 % This is an author-year citation style bibliography. As such, it is
 % non-standard LaTeX, and requires a special package file to function properly.
 % Such a package is    natbib.sty   by Patrick W. Daly
 % The form of the \bibitem entries is
 %   \bibitem[Jones et al.(1990)]{key}...
 %   \bibitem[Jones et al.(1990)Jones, Baker, and Smith]{key}...
 % The essential feature is that the label (the part in brackets) consists
 % of the author names, as they should appear in the citation, with the year
 % in parentheses following. There must be no space before the opening
 % parenthesis!
 % With natbib v5.3, a full list of authors may also follow the year.
 % In natbib.sty, it is possible to define the type of enclosures that is
 % really wanted (brackets or parentheses), but in either case, there must
 % be parentheses in the label.
 % The \cite command functions as follows:
 %   \citet{key} ==>>                Jones et al. (1990)
 %   \citet*{key} ==>>               Jones, Baker, and Smith (1990)
 %   \citep{key} ==>>                (Jones et al., 1990)
 %   \citep*{key} ==>>               (Jones, Baker, and Smith, 1990)
 %   \citep[chap. 2]{key} ==>>       (Jones et al., 1990, chap. 2)
 %   \citep[e.g.][]{key} ==>>        (e.g. Jones et al., 1990)
 %   \citep[e.g.][p. 32]{key} ==>>   (e.g. Jones et al., p. 32)
 %   \citeauthor{key} ==>>           Jones et al.
 %   \citeauthor*{key} ==>>          Jones, Baker, and Smith
 %   \citeyear{key} ==>>             1990
 %---------------------------------------------------------------------

FUNCTION {id.bst} {"Merlin.mbs v4.21 2009-07-09. "}
ENTRY
{
    address
    archive
    archivePrefix
    author
    bookaddress
    booktitle
    chapter
    collaboration
    doi
    edition
    editor
    eid
    eprint
    howpublished
    institution
    isbn
    issn
    journal
    key
    language
    month
    note
    number
    organization
    pages
    primaryClass
    publisher
    school
    SLACcitation
    series
    title
    translation
    type
    url
    volume
    year
}{
}{
    label
    extra.label sort.label
    short.list
}

INTEGERS
{
  output.state before.all
  after.word after.punctuation
  after.sentence after.block
}

INTEGERS
{
  punctuation.state punctuation.no punctuation.space punctuation.yes
}

STRINGS { bibfield output.bibfield }
FUNCTION {not}
{   { #0 }
    { #1 }
  if$
}

FUNCTION {and}
{   'skip$
    { pop$ #0 }
  if$
}

FUNCTION {or}
{   { pop$ #1 }
    'skip$
  if$
}

FUNCTION {non.stop}
{ duplicate$
   "}" * add.period$
   #-1 #1 substring$ "." =
}

FUNCTION {init.state.consts}
{
  #0 'before.all        :=
  #1 'after.word        :=
  #2 'after.punctuation :=
  #3 'after.sentence    :=
  #4 'after.block       :=
  #0 'punctuation.no    :=
  #1 'punctuation.space :=
  #2 'punctuation.yes   :=
  "" 'bibfield          :=
  "" 'output.bibfield   :=
}

STRINGS { s t}
FUNCTION {block.punctuation}
{ ""
  "," *
}

FUNCTION {word.space}
{
  "\ "
}

FUNCTION {show.stackstring.one}{
  "(" *
  output.state int.to.str$ *
    "," * punctuation.state int.to.str$ *
  ")" * top$
  duplicate$ "1(" swap$ * ")" * top$
}

FUNCTION {show.stackstring.two}{
  "(" *
  output.state int.to.str$ *
    "," * punctuation.state int.to.str$ *
  ")" * top$
  swap$
  duplicate$ "1(" swap$ * ")" * top$
  swap$
  duplicate$ "2(" swap$ * ")" * top$
}

FUNCTION {bibfield.command}{ "\bibfield"}

FUNCTION {output.nonnull}
{
  swap$
  output.state after.word =
    {
      block.punctuation *
      word.space *
    }
    {
      output.state after.punctuation =
        {
          word.space *
        }
        {
          output.state after.block = output.state after.sentence = or
            {
              add.period$
              "\EOS\ " *
            }{
            }
          if$
        }
      if$
    }
  if$
  output.bibfield duplicate$ empty$ 'pop$
    {
      bibfield.command
      "{" * swap$ * "}{%" * write$ newline$
      "  "  swap$ * "}%"  * write$ newline$
      "  "
    }
  if$
  write$
  bibfield 'output.bibfield := "" 'bibfield :=
  output.state after.block =
    {
      newline$
      "\newblock " write$
    }
    'skip$
  if$
  punctuation.state duplicate$
  punctuation.yes 'punctuation.state :=
  punctuation.no =
    { pop$ before.all }
    { punctuation.yes = { after.word }{ after.punctuation } if$ }
  if$
  'output.state :=
}

FUNCTION {output}
{ duplicate$ empty$
    {
      pop$
  "" 'bibfield :=
    }
    'output.nonnull
  if$
}

FUNCTION {output.check}
{ swap$
  duplicate$ empty$
    { pop$ "empty " swap$ * " in " * cite$ * warning$ }
    { swap$ pop$ output.nonnull }
  if$
}

FUNCTION {bbl.open} { "\BibitemOpen" }

FUNCTION {bbl.shut} { "\BibitemShut" }

FUNCTION {bibitem.shut.stop} { bbl.shut "{Stop}%" * }

FUNCTION {bibitem.shut.nostop} { bbl.shut "{NoStop}%" * }

FUNCTION {bibitem.shut}
{
  non.stop
    {
  bibitem.shut.nostop *
    }{
  bibitem.shut.stop *
    }
  if$
}

FUNCTION {html.itag} {
  "p"
}

FUNCTION {html.ltag} {
  ""
}

FUNCTION {output.SLACcitation}
{ SLACcitation empty$
    'skip$
    {
      newline$
      SLACcitation write$
    }
  if$
}

FUNCTION {fin.entry}
{
  bibitem.shut
  write$
    output.SLACcitation
}

FUNCTION {new.block}
{ output.state before.all =
    'skip$
    { after.block 'output.state := }
  if$
}

FUNCTION {new.block.comma}
{
}

FUNCTION {new.sentence}
{ output.state after.block = output.state before.all = or
    'skip$
    { after.sentence 'output.state := }
  if$
}

FUNCTION {new.sentence.comma}
{
}

FUNCTION {sentence.or.colon}
{
  new.sentence
}

FUNCTION {add.blank}
{
  word.space *
  before.all 'output.state :=
}

FUNCTION {no.blank.or.punct}
{
   "\hspace{0pt}" *
   before.all 'output.state :=
}

FUNCTION {date.block}
{
  new.block.comma
  skip$
}

FUNCTION {new.block.checkb}
{ empty$
  swap$ empty$
  and
    'skip$
    'new.block
  if$
}

FUNCTION {field.or.null}
{ duplicate$ empty$
    { pop$ "" }
    'skip$
  if$
}

FUNCTION {emphasize}
{
  duplicate$ empty$
    { pop$ "" }
    {
      "\emph{" swap$ * "}" *
    }
  if$
}

FUNCTION {bolden}
{ duplicate$ empty$
    { pop$ "" }
    { "\textbf{" swap$ * "}" * }
  if$
}

FUNCTION {bib.name.font}
{
  duplicate$ empty$
    { pop$ "" }
    {
    "\bibnamefont{" swap$ * "}" *
    }
  if$
}

FUNCTION {bib.fname.font}
{
  duplicate$ empty$
    { pop$ "" }
    {
    "\bibfnamefont{" swap$ * "}" *
    }
  if$
}

FUNCTION {cite.name.font}
{
  duplicate$ empty$
    { pop$ "" }
    {
    "\citenamefont{" swap$ * "}" *
    }
  if$
}

FUNCTION {tie.or.space.prefix}
{ duplicate$ text.length$ #3 <
    { "~" }
    { word.space }
  if$
  swap$
}

FUNCTION {capitalize}
{
  "u" change.case$ "t" change.case$
}

FUNCTION {space.word}
{ word.space swap$ * word.space * }

 % Here are the language-specific definitions for explicit words.
 % Each function has a name bbl.xxx where xxx is the English word.
 % The language selected here is ENGLISH
FUNCTION {bbl.and}
{
  "and"
}

FUNCTION {bbl.etal}
{
  "et~al."
}

FUNCTION {bbl.editors}
{
  "eds."
}

FUNCTION {bbl.editor}
{
  "ed."
}

FUNCTION {bbl.edby}
{ "edited by" }

FUNCTION {bbl.edition}
{
  "ed."
}

FUNCTION {bbl.volume}
{
  "vol."
}

FUNCTION {bbl.of}
{ "of" }

FUNCTION {bbl.number}
{
  "no."
}

FUNCTION {bbl.nr}
{ "no." }

FUNCTION {bbl.in}
{ "in" }

FUNCTION {bbl.pages}
{
  "pp."
}

FUNCTION {bbl.page}
{
  "p."
}

FUNCTION {bbl.eidpp}
{ "pages" }

FUNCTION {bbl.chapter}
{
  "chap."
}

FUNCTION {bbl.techrep}
{
  "Tech. Rep."
}

FUNCTION {bbl.mthesis}
{ "Master's thesis" }

FUNCTION {bbl.phdthesis}
{ "Ph.D. thesis" }

FUNCTION {bbl.first}
{
  "1st"
}

FUNCTION {bbl.second}
{
  "2nd"
}

FUNCTION {bbl.third}
{
  "3rd"
}

FUNCTION {bbl.fourth}
{
  "4th"
}

FUNCTION {bbl.fifth}
{
  "5th"
}

FUNCTION {bbl.st}
{ "st" }

FUNCTION {bbl.nd}
{ "nd" }

FUNCTION {bbl.rd}
{ "rd" }

FUNCTION {bbl.th}
{ "th" }

MACRO {jan} {"Jan."}

MACRO {feb} {"Feb."}

MACRO {mar} {"Mar."}

MACRO {apr} {"Apr."}

MACRO {may} {"May"}

MACRO {jun} {"Jun."}

MACRO {jul} {"Jul."}

MACRO {aug} {"Aug."}

MACRO {sep} {"Sep."}

MACRO {oct} {"Oct."}

MACRO {nov} {"Nov."}

MACRO {dec} {"Dec."}

FUNCTION {bbl.url.prefix}
{
  "\urlprefix"
}

FUNCTION {eng.ord}
{ duplicate$ "1" swap$ *
  #-2 #1 substring$ "1" =
     { bbl.th * }
     { duplicate$ #-1 #1 substring$
       duplicate$ "1" =
         { pop$ bbl.st * }
         { duplicate$ "2" =
             { pop$ bbl.nd * }
             { "3" =
                 { bbl.rd * }
                 { bbl.th * }
               if$
             }
           if$
          }
       if$
     }
   if$
}

 %-------------------------------------------------------------------
 % Begin module:
 % \ProvidesFile{physjour.mbs}[2002/01/14 2.2 (PWD)]
MACRO {aa}{"Astron. \& Astrophys."}
MACRO {aasup}{"Astron. \& Astrophys. Suppl. Ser."}
MACRO {aj} {"Astron. J."}
MACRO {aph} {"Acta Phys."}
MACRO {advp} {"Adv. Phys."}
MACRO {ajp} {"Amer. J. Phys."}
MACRO {ajm} {"Amer. J. Math."}
MACRO {amsci} {"Amer. Sci."}
MACRO {anofd} {"Ann. Fluid Dyn."}
MACRO {am} {"Ann. Math."}
MACRO {ap} {"Ann. Phys. (NY)"}
MACRO {adp} {"Ann. Phys. (Leipzig)"}
MACRO {ao} {"Appl. Opt."}
MACRO {apl} {"Appl. Phys. Lett."}
MACRO {app} {"Astroparticle Phys."}
MACRO {apj} {"Astrophys. J."}
MACRO {apjsup} {"Astrophys. J. Suppl."}
MACRO {apss} {"Astrophys. Space Sci."}
MACRO {araa} {"Ann. Rev. Astron. Astrophys."}
MACRO {baas} {"Bull. Amer. Astron. Soc."}
MACRO {baps} {"Bull. Amer. Phys. Soc."}
MACRO {cmp} {"Comm. Math. Phys."}
MACRO {cpam} {"Commun. Pure Appl. Math."}
MACRO {cppcf} {"Comm. Plasma Phys. \& Controlled Fusion"}
MACRO {cpc} {"Comp. Phys. Comm."}
MACRO {cqg} {"Class. Quant. Grav."}
MACRO {cra} {"C. R. Acad. Sci. A"}
MACRO {fed} {"Fusion Eng. \& Design"}
MACRO {ft} {"Fusion Tech."}
MACRO {grg} {"Gen. Relativ. Gravit."}
MACRO {ieeens} {"IEEE Trans. Nucl. Sci."}
MACRO {ieeeps} {"IEEE Trans. Plasma Sci."}
MACRO {ijimw} {"Interntl. J. Infrared \& Millimeter Waves"}
MACRO {ip} {"Infrared Phys."}
MACRO {irp} {"Infrared Phys."}
MACRO {jap} {"J. Appl. Phys."}
MACRO {jasa} {"J. Acoust. Soc. America"}
MACRO {jcp} {"J. Comp. Phys."}
MACRO {jetp} {"Sov. Phys.--JETP"}
MACRO {jfe} {"J. Fusion Energy"}
MACRO {jfm} {"J. Fluid Mech."}
MACRO {jmp} {"J. Math. Phys."}
MACRO {jne} {"J. Nucl. Energy"}
MACRO {jnec} {"J. Nucl. Energy, C: Plasma Phys., Accelerators, Thermonucl. Res."}
MACRO {jnm} {"J. Nucl. Mat."}
MACRO {jpc} {"J. Phys. Chem."}
MACRO {jpp} {"J. Plasma Phys."}
MACRO {jpsj} {"J. Phys. Soc. Japan"}
MACRO {jsi} {"J. Sci. Instrum."}
MACRO {jvst} {"J. Vac. Sci. \& Tech."}
MACRO {nat} {"Nature"}
MACRO {nature} {"Nature"}
MACRO {nedf} {"Nucl. Eng. \& Design/Fusion"}
MACRO {nf} {"Nucl. Fusion"}
MACRO {nim} {"Nucl. Inst. \& Meth."}
MACRO {nimpr} {"Nucl. Inst. \& Meth. in Phys. Res."}
MACRO {np} {"Nucl. Phys."}
MACRO {npb} {"Nucl. Phys. B"}
MACRO {nt/f} {"Nucl. Tech./Fusion"}
MACRO {npbpc} {"Nucl. Phys. B (Proc. Suppl.)"}
MACRO {inc} {"Nuovo Cimento"}
MACRO {nc} {"Nuovo Cimento"}
MACRO {pf} {"Phys. Fluids"}
MACRO {pfa} {"Phys. Fluids A: Fluid Dyn."}
MACRO {pfb} {"Phys. Fluids B: Plasma Phys."}
MACRO {pl} {"Phys. Lett."}
MACRO {pla} {"Phys. Lett. A"}
MACRO {plb} {"Phys. Lett. B"}
MACRO {prep} {"Phys. Rep."}
MACRO {pnas} {"Proc. Nat. Acad. Sci. USA"}
MACRO {pp} {"Phys. Plasmas"}
MACRO {ppcf} {"Plasma Phys. \& Controlled Fusion"}
MACRO {phitrsl} {"Philos. Trans. Roy. Soc. London"}
MACRO {prl} {"Phys. Rev. Lett."}
MACRO {pr} {"Phys. Rev."}
MACRO {physrev} {"Phys. Rev."}
MACRO {pra} {"Phys. Rev. A"}
MACRO {prb} {"Phys. Rev. B"}
MACRO {prc} {"Phys. Rev. C"}
MACRO {prd} {"Phys. Rev. D"}
MACRO {pre} {"Phys. Rev. E"}
MACRO {ps} {"Phys. Scripta"}
MACRO {procrsl} {"Proc. Roy. Soc. London"}
MACRO {rmp} {"Rev. Mod. Phys."}
MACRO {rsi} {"Rev. Sci. Inst."}
MACRO {science} {"Science"}
MACRO {sciam} {"Sci. Am."}
MACRO {sam} {"Stud. Appl. Math."}
MACRO {sjpp} {"Sov. J. Plasma Phys."}
MACRO {spd} {"Sov. Phys.--Doklady"}
MACRO {sptp} {"Sov. Phys.--Tech. Phys."}
MACRO {spu} {"Sov. Phys.--Uspeki"}
MACRO {st} {"Sky and Telesc."}
 % End module: physjour.mbs
 %-------------------------------------------------------------------
 % Begin module:
 % \ProvidesFile{geojour.mbs}[2002/07/10 2.0h (PWD)]
MACRO {aisr} {"Adv. Space Res."}
MACRO {ag} {"Ann. Geophys."}
MACRO {anigeo} {"Ann. Geofis."}
MACRO {angl} {"Ann. Glaciol."}
MACRO {andmet} {"Ann. d. Meteor."}
MACRO {andgeo} {"Ann. d. Geophys."}
MACRO {andphy} {"Ann. Phys.-Paris"}
MACRO {afmgb} {"Arch. Meteor. Geophys. Bioklimatol."}
MACRO {atph} {"Atm\'osphera"}
MACRO {aao} {"Atmos. Ocean"}
MACRO {ass}{"Astrophys. Space Sci."}
MACRO {atenv} {"Atmos. Environ."}
MACRO {aujag} {"Aust. J. Agr. Res."}
MACRO {aumet} {"Aust. Meteorol. Mag."}
MACRO {blmet} {"Bound.-Lay. Meteorol."}
MACRO {bams} {"Bull. Amer. Meteorol. Soc."}
MACRO {cch} {"Clim. Change"}
MACRO {cdyn} {"Clim. Dynam."}
MACRO {cbul} {"Climatol. Bull."}
MACRO {cap} {"Contrib. Atmos. Phys."}
MACRO {dsr} {"Deep-Sea Res."}
MACRO {dhz} {"Dtsch. Hydrogr. Z."}
MACRO {dao} {"Dynam. Atmos. Oceans"}
MACRO {eco} {"Ecology"}
MACRO {empl}{"Earth, Moon and Planets"}
MACRO {envres} {"Environ. Res."}
MACRO {envst} {"Environ. Sci. Technol."}
MACRO {ecms} {"Estuarine Coastal Mar. Sci."}
MACRO {expa}{"Exper. Astron."}
MACRO {geoint} {"Geofis. Int."}
MACRO {geopub} {"Geofys. Publ."}
MACRO {geogeo} {"Geol. Geofiz."}
MACRO {gafd} {"Geophys. Astrophys. Fluid Dyn."}
MACRO {gfd} {"Geophys. Fluid Dyn."}
MACRO {geomag} {"Geophys. Mag."}
MACRO {georl} {"Geophys. Res. Lett."}
MACRO {grl} {"Geophys. Res. Lett."}
MACRO {ga} {"Geophysica"}
MACRO {gs} {"Geophysics"}
MACRO {ieeetap} {"IEEE Trans. Antenn. Propag."}
MACRO {ijawp} {"Int. J. Air Water Pollut."}
MACRO {ijc} {"Int. J. Climatol."}
MACRO {ijrs} {"Int. J. Remote Sens."}
MACRO {jam} {"J. Appl. Meteorol."}
MACRO {jaot} {"J. Atmos. Ocean. Technol."}
MACRO {jatp} {"J. Atmos. Terr. Phys."}
MACRO {jastp} {"J. Atmos. Solar-Terr. Phys."}
MACRO {jce} {"J. Climate"}
MACRO {jcam} {"J. Climate Appl. Meteor."}
MACRO {jcm} {"J. Climate Meteor."}
MACRO {jcy} {"J. Climatol."}
MACRO {jgr} {"J. Geophys. Res."}
MACRO {jga} {"J. Glaciol."}
MACRO {jh} {"J. Hydrol."}
MACRO {jmr} {"J. Mar. Res."}
MACRO {jmrj} {"J. Meteor. Res. Japan"}
MACRO {jm} {"J. Meteor."}
MACRO {jpo} {"J. Phys. Oceanogr."}
MACRO {jra} {"J. Rech. Atmos."}
MACRO {jaes} {"J. Aeronaut. Sci."}
MACRO {japca} {"J. Air Pollut. Control Assoc."}
MACRO {jas} {"J. Atmos. Sci."}
MACRO {jmts} {"J. Mar. Technol. Soc."}
MACRO {jmsj} {"J. Meteorol. Soc. Japan"}
MACRO {josj} {"J. Oceanogr. Soc. Japan"}
MACRO {jwm} {"J. Wea. Mod."}
MACRO {lao} {"Limnol. Oceanogr."}
MACRO {mwl} {"Mar. Wea. Log"}
MACRO {mau} {"Mausam"}
MACRO {meteor} {"``Meteor'' Forschungsergeb."}
MACRO {map} {"Meteorol. Atmos. Phys."}
MACRO {metmag} {"Meteor. Mag."}
MACRO {metmon} {"Meteor. Monogr."}
MACRO {metrun} {"Meteor. Rundsch."}
MACRO {metzeit} {"Meteor. Z."}
MACRO {metgid} {"Meteor. Gidrol."}
MACRO {mwr} {"Mon. Weather Rev."}
MACRO {nwd} {"Natl. Weather Dig."}
MACRO {nzjmfr} {"New Zeal. J. Mar. Freshwater Res."}
MACRO {npg} {"Nonlin. Proc. Geophys."}
MACRO {om} {"Oceanogr. Meteorol."}
MACRO {ocac} {"Oceanol. Acta"}
MACRO {oceanus} {"Oceanus"}
MACRO {paleoc} {"Paleoceanography"}
MACRO {pce} {"Phys. Chem. Earth"}
MACRO {pmg} {"Pap. Meteor. Geophys."}
MACRO {ppom} {"Pap. Phys. Oceanogr. Meteor."}
MACRO {physzeit} {"Phys. Z."}
MACRO {pps} {"Planet. Space Sci."}
MACRO {pss} {"Planet. Space Sci."}
MACRO {pag} {"Pure Appl. Geophys."}
MACRO {qjrms} {"Quart. J. Roy. Meteorol. Soc."}
MACRO {quatres} {"Quat. Res."}
MACRO {rsci} {"Radio Sci."}
MACRO {rse} {"Remote Sens. Environ."}
MACRO {rgeo} {"Rev. Geophys."}
MACRO {rgsp} {"Rev. Geophys. Space Phys."}
MACRO {rdgeo} {"Rev. Geofis."}
MACRO {revmeta} {"Rev. Meteorol."}
MACRO {sgp}{"Surveys in Geophys."}
MACRO {sp} {"Solar Phys."}
MACRO {ssr} {"Space Sci. Rev."}
MACRO {tellus} {"Tellus"}
MACRO {tac} {"Theor. Appl. Climatol."}
MACRO {tagu} {"Trans. Am. Geophys. Union (EOS)"}
MACRO {wrr} {"Water Resour. Res."}
MACRO {weather} {"Weather"}
MACRO {wafc} {"Weather Forecast."}
MACRO {ww} {"Weatherwise"}
MACRO {wmob} {"WMO Bull."}
MACRO {zeitmet} {"Z. Meteorol."}
 % End module: geojour.mbs
 %-------------------------------------------------------------------
 % Begin module:
 % \ProvidesFile{photjour.mbs}[1999/02/24 2.0b (PWD)]

MACRO {appopt} {"Appl. Opt."}
MACRO {bell} {"Bell Syst. Tech. J."}
MACRO {ell} {"Electron. Lett."}
MACRO {jasp} {"J. Appl. Spectr."}
MACRO {jqe} {"IEEE J. Quantum Electron."}
MACRO {jlwt} {"J. Lightwave Technol."}
MACRO {jmo} {"J. Mod. Opt."}
MACRO {josa} {"J. Opt. Soc. America"}
MACRO {josaa} {"J. Opt. Soc. Amer.~A"}
MACRO {josab} {"J. Opt. Soc. Amer.~B"}
MACRO {jdp} {"J. Phys. (Paris)"}
MACRO {oc} {"Opt. Commun."}
MACRO {ol} {"Opt. Lett."}
MACRO {phtl} {"IEEE Photon. Technol. Lett."}
MACRO {pspie} {"Proc. Soc. Photo-Opt. Instrum. Eng."}
MACRO {sse} {"Solid-State Electron."}
MACRO {sjot} {"Sov. J. Opt. Technol."}
MACRO {sjqe} {"Sov. J. Quantum Electron."}
MACRO {sleb} {"Sov. Phys.--Leb. Inst. Rep."}
MACRO {stph} {"Sov. Phys.--Techn. Phys."}
MACRO {stphl} {"Sov. Techn. Phys. Lett."}
MACRO {vr} {"Vision Res."}
MACRO {zph} {"Z. f. Physik"}
MACRO {zphb} {"Z. f. Physik~B"}
MACRO {zphd} {"Z. f. Physik~D"}

MACRO {CLEO} {"CLEO"}
MACRO {ASSL} {"Adv. Sol.-State Lasers"}
MACRO {OSA}  {"OSA"}
 % End module: photjour.mbs
%% Copyright 1994-2007 Patrick W Daly
MACRO {acmcs} {"ACM Comput. Surv."}

MACRO {acta} {"Acta Inf."}

MACRO {cacm} {"Commun. ACM"}

MACRO {ibmjrd} {"IBM J. Res. Dev."}

MACRO {ibmsj} {"IBM Syst.~J."}

MACRO {ieeese} {"IEEE Trans. Software Eng."}

MACRO {ieeetc} {"IEEE Trans. Comput."}

MACRO {ieeetcad}
 {"IEEE Trans. Comput. Aid. Des."}

MACRO {ipl} {"Inf. Process. Lett."}

MACRO {jacm} {"J.~ACM"}

MACRO {jcss} {"J.~Comput. Syst. Sci."}

MACRO {scp} {"Sci. Comput. Program."}

MACRO {sicomp} {"SIAM J. Comput."}

MACRO {tocs} {"ACM Trans. Comput. Syst."}

MACRO {tods} {"ACM Trans. Database Syst."}

MACRO {tog} {"ACM Trans. Graphic."}

MACRO {toms} {"ACM Trans. Math. Software"}

MACRO {toois} {"ACM Trans. Office Inf. Syst."}

MACRO {toplas} {"ACM Trans. Progr. Lang. Syst."}

MACRO {tcs} {"Theor. Comput. Sci."}

FUNCTION {bibinfo.command} { "\bibinfo" }

FUNCTION {bibinfo.check}
{ swap$
  duplicate$ missing$
    {
      pop$
      pop$ ""
    }{
      duplicate$ empty$
        {
          swap$ pop$
        }{
          swap$
          bibinfo.command " {" * swap$ * "} {" * swap$ * "}" *
        }
      if$
    }
  if$
}

FUNCTION {bibinfo.warn}
{ swap$
  duplicate$ missing$
    {
      swap$ "missing " swap$ * " in " * cite$ * warning$ pop$
      ""
    }{
      duplicate$ empty$
        {
          swap$ "empty " swap$ * " in " * cite$ * warning$
        }{
          swap$
          bibinfo.command " {" * swap$ * "} {" * swap$ * "}" *
        }
      if$
    }
  if$
}

FUNCTION {archiv.base}
{
  "http://arxiv.org/abs"
}

FUNCTION {archiv.prefix.base}
{
  "arXiv"
}

FUNCTION {eprint.command}
{
  "\Eprint"
}

FUNCTION {format.eprint}
{ eprint duplicate$ empty$
    { pop$ "" }
    {
      duplicate$
      ""
        archive duplicate$ empty$ { pop$ archiv.base } 'skip$ if$ *
        "/" *
        swap$ *
        "{" swap$ * "}" *
      swap$
      ""
        archivePrefix duplicate$ empty$ { pop$ "" } { ":" * } if$ *
        swap$ *
        primaryClass  duplicate$ empty$ { pop$ "" } { " [" swap$ * "]" * } if$ *
        "{" swap$ * "}" *
      *
      eprint.command swap$ *
    }
  if$
}

FUNCTION {format.translation}
{ translation duplicate$ empty$
    'skip$
    { ""
      "\translation{" * swap$ * "}" *
      punctuation.space 'punctuation.state :=
    }
  if$
}

FUNCTION {format.url}
{
  url duplicate$ empty$
    { pop$ "" }
    {
      "\url"
      "{" * swap$ * "}" *
    }
  if$
}

INTEGERS { nameptr namesleft numnames }

FUNCTION {check.speaker}
{ key empty$ 'skip$
  { key nameptr int.to.str$ =
    {
      bolden
    }
      'skip$
    if$
  }
  if$
}


STRINGS  { bibinfo}

FUNCTION {format.names}
{ 'bibinfo :=
  duplicate$ empty$ 'skip$ {
  's :=
  "" 't :=
  #1 'nameptr :=
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    { s nameptr
      "{vv~}{ll}" format.name$ bib.name.font
      s nameptr
      "{jj, }{ff}"
      format.name$ duplicate$ empty$ 'skip$
        { bib.fname.font ", " swap$ * }
      if$
      *
      bibinfo bibinfo.check
      type$ "presentation" =
        { check.speaker }
        'skip$
      if$
      't :=
      nameptr #1 >
        {
          namesleft #1 >
            {
              ", " *
              t *
            }{
              s nameptr "{ll}" format.name$ duplicate$ "others" =
                { 't := }
                { pop$ }
              if$
              numnames #2 >
                {
                  "," *
                }
                'skip$
              if$
              t "others" =
                {
                  " " * bbl.etal
                  emphasize
                  *
                }{
                  bbl.and
                  space.word *
                  t *
                }
              if$
            }
          if$
        }
        't
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
  } if$
}

FUNCTION {format.names.ed}
{
  'bibinfo :=
  duplicate$ empty$ 'skip$ {
  's :=
  "" 't :=
  #1 'nameptr :=
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    { s nameptr
      "{ff}" format.name$ duplicate$ empty$ 'skip$
        { tie.or.space.prefix bib.fname.font swap$ * }
      if$
      s nameptr
      "{vv~}{ll}" format.name$ bib.name.font *
      s nameptr
      "{jj}" format.name$ duplicate$ empty$ 'skip$
        { bib.fname.font ", " swap$ * }
      if$
      *
      bibinfo bibinfo.check
      't :=
      nameptr #1 >
        {
          namesleft #1 >
            {
              ", " *
              t *
            }{
              s nameptr "{ll}" format.name$ duplicate$ "others" =
                { 't := }
                { pop$ }
              if$
              numnames #2 >
                {
                  "," *
                }
                { skip$ }
              if$
              t "others" =
                {

                  " " * bbl.etal emphasize *
                }{
                  bbl.and
                  space.word * t *
                }
              if$
            }
          if$
        }
        't
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
  } if$
}

FUNCTION {format.key}
{ empty$
    { key field.or.null }
    { "" }
  if$
}

FUNCTION {format.authors}
{ author "author" format.names
  duplicate$ empty$ 'skip$
    { collaboration "collaboration" bibinfo.check
      duplicate$ empty$ 'skip$
        { " (" swap$ * ")" * }
      if$
      *
    }
  if$
  "author" 'bibfield :=
}

FUNCTION {get.bbl.editor}
{ editor num.names$ #1 > 'bbl.editors 'bbl.editor if$
}

FUNCTION {format.editors}
{ editor "editor" format.names duplicate$ empty$ 'skip$
    {
      "," *
      word.space *
      get.bbl.editor
      *
    }
  if$
}

FUNCTION {format.isbn}
{
  isbn "isbn" bibinfo.check
  duplicate$ empty$ 'skip$
    {
      new.block.comma
      "ISBN " swap$ *
    }
  if$
}

FUNCTION {format.issn}
{ issn "issn" bibinfo.check
  duplicate$ empty$ 'skip$
    {
      new.block.comma
      "ISSN " swap$ *
    }
  if$
}

FUNCTION {doi.base}
{
  "http://dx.doi.org/"
}

FUNCTION {doi.command}
{
  "\doi"
}

FUNCTION {doi.command.href}
{
  "\Doi"
}

FUNCTION {format.doi}
{ doi "doi" bibinfo.check
  duplicate$ empty$ 'skip$
    {
      new.block.comma
      doi.command "{" * swap$ * "}" *
    }
  if$
}

FUNCTION {add.doi}
{
  duplicate$ empty$ 'skip$
    {
      doi duplicate$ empty$ 'pop$
        {
          "{" swap$ * "}" *
          swap$
          "{" swap$ * "}" *
          *
          doi.command.href swap$ *
        }
      if$
    }
  if$
}

FUNCTION {select.language}
{ duplicate$ empty$
    'pop$
    { language empty$
        'skip$
        { "{\selectlanguage {" language * "}" * swap$ * "}" * }
      if$
    }
    if$
}

FUNCTION {format.note}
{
 note empty$
    { "" }
    { note #1 #1 substring$
      duplicate$ "{" =
        'skip$
        {
          output.state after.word = output.state after.punctuation = or
            { "l" }
            { "u" }
          if$ change.case$
        }
      if$
      note #2 global.max$ substring$ * "note" bibinfo.check
    }
  if$
}

FUNCTION {bbl.enquote}
{
  "\enquote"
}

FUNCTION {string.enquote}
{
  punctuation.no 'punctuation.state :=
  non.stop {
    block.punctuation
  } { "." } if$
   swap$ pop$
  *
  bbl.enquote "{" * swap$ * "}" *
  word.space *
}

FUNCTION {format.title}
{ title
  duplicate$ empty$ 'skip$ { "t" change.case$ } if$
  duplicate$ "title" bibinfo.check swap$
  duplicate$ empty$ 'pop$
    {
      punctuation.yes 'punctuation.state :=
      string.enquote
      select.language
    }
  if$
}

FUNCTION {end.quote.title}
{ title empty$
    'skip$
    { before.all 'output.state := }
  if$
}

FUNCTION {format.full.names}
{
  's :=
  "" 't :=
  #1 'nameptr :=
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    { s nameptr
      "{vv~}{ll}"
      format.name$
      cite.name.font
      't :=
      nameptr #1 >
        {
          namesleft #1 >
            { ", " * t * }
            {
              s nameptr "{ll}" format.name$ duplicate$ "others" =
                {
                  't :=
                }
                'pop$
              if$
              t "others" =
                {
                  " " * bbl.etal
                  emphasize *
                }{
                  numnames #2 > { "," * }{ skip$ } if$
                  bbl.and
                  space.word * t *
                }
              if$
            }
          if$
        }
        't
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}

FUNCTION {make.full.names}
{
  key editor author
  type$ "proceedings" =
  type$ "book"        =
  type$ "inbook"      =
  or { pop$ }{ { pop$ "" }{ swap$ pop$ "" swap$ } if$ } if$
  duplicate$ empty$
    { pop$
      duplicate$ empty$
        { pop$
          duplicate$ empty$
            { pop$
              cite$ #1 #3 substring$
            }{
              skip$
            }
          if$
        }
        { swap$ pop$ format.full.names }
      if$
    }
    { swap$ pop$ swap$ pop$ format.full.names }
  if$
}

FUNCTION {year.bibitem}
{
  year duplicate$ empty$
  { pop$ ""
  }{
    skip$
  } if$
  extra.label *
}

FUNCTION {output.bibitem}
{
  newline$
  ""
  label
  *
  ")" *
   make.full.names duplicate$ short.list =
   { pop$ }{ * } if$
  "{" swap$ * "}" *
  "[" swap$ * "]" *
  "{" * cite$ * "}%" *
  "\bibitem"
  swap$ *
  write$ newline$
  "  "
  duplicate$ bbl.open * write$ newline$
  before.all 'output.state :=
  punctuation.yes 'punctuation.state :=
}

FUNCTION {n.dashify}
{
  't :=
  ""
    { t empty$ not }
    { t #1 #1 substring$ "-" =
        { t #1 #2 substring$ "--" = not
            { "--" *
              t #2 global.max$ substring$ 't :=
            }{
                { t #1 #1 substring$ "-" = }
                { "-" *
                  t #2 global.max$ substring$ 't :=
                }
              while$
            }
          if$
        }{
          t #1 #1 substring$ *
          t #2 global.max$ substring$ 't :=
        }
      if$
    }
  while$
}

FUNCTION {word.in}
{
  bbl.in
  word.space *
}

FUNCTION {date.encapsulate}
{
  duplicate$ empty$
    'skip$
    {
      before.all 'output.state :=
      " (" swap$ * ")" *
    }
  if$
}

FUNCTION {format.date}
{
  year "year" bibinfo.check duplicate$ empty$
    {
    }
    'skip$
  if$
  extra.label *
  date.encapsulate
}

FUNCTION {format.date.output.check}
{
 format.date
 "year" output.check
}

FUNCTION {format.date.output}
{
  format.date.output.check
}

FUNCTION {format.btitle}
{
  booktitle duplicate$ empty$ { pop$
      title
  } 'skip$ if$
  "title" bibinfo.check
  duplicate$ empty$ 'skip$
    {
      emphasize
      select.language
    }
  if$
}

FUNCTION {either.or.check}
{ empty$
    'pop$
    { "can't use both " swap$ * " fields in " * cite$ * warning$ }
  if$
}

FUNCTION {editor.check.book}
{ editor empty$ 'skip$
    {
      "can't use both author and editor fields in " cite$ *
      ": try using @inbook instead" *
      warning$
    }
  if$
}

FUNCTION {format.bvolume}
{ volume duplicate$ empty$
    { pop$ "" }
    {
      "volume and number" number either.or.check
      bbl.volume
      capitalize
      swap$
      tie.or.space.prefix "volume" bibinfo.check * *
      series "series" bibinfo.check duplicate$ empty$ 'pop$
        {
          ", "
          * swap$ *
        }
      if$
    }
  if$
}

FUNCTION {format.number}
{
  bbl.number
  output.state after.word = output.state after.punctuation = or
  #1 or
  #0 and
    'skip$
    { capitalize }
  if$
  number tie.or.space.prefix "number" bibinfo.check * *
}

FUNCTION {format.number.series}
{ volume empty$
    { number empty$
        { series field.or.null }
        {
          series empty$
            {
              number "number" bibinfo.check
            }{
              format.number
              series "series" bibinfo.check
              word.space * swap$ *
            }
          if$
        }
      if$
    }
    { "" }
  if$
}

FUNCTION {is.num}
{ chr.to.int$
  duplicate$ "0" chr.to.int$ < not
  swap$ "9" chr.to.int$ > not and
}

FUNCTION {extract.num}
{ duplicate$ 't :=
  "" 's :=
  { t empty$ not }
  { t #1 #1 substring$
    t #2 global.max$ substring$ 't :=
    duplicate$ is.num
      { s swap$ * 's := }
      { pop$ "" 't := }
    if$
  }
  while$
  s empty$
    'skip$
    { pop$ s }
  if$
}

FUNCTION {convert.edition}
{ extract.num "l" change.case$ 's :=
  s "first" = s "1" = or
    { bbl.first 't := }
    { s "second" = s "2" = or
        { bbl.second 't := }
        { s "third" = s "3" = or
            { bbl.third 't := }
            { s "fourth" = s "4" = or
                { bbl.fourth 't := }
                { s "fifth" = s "5" = or
                    { bbl.fifth 't := }
                    { s #1 #1 substring$ is.num
                        { s
                            eng.ord
                        't := }
                        { edition 't := }
                      if$
                    }
                  if$
                }
              if$
            }
          if$
        }
      if$
    }
  if$
  t
}

FUNCTION {format.edition}
{ edition duplicate$ empty$ 'skip$
    {
      convert.edition
      output.state after.word = output.state after.punctuation = or
        { "l" }
        { "t" }
      if$ change.case$
      "edition" bibinfo.check
      word.space * bbl.edition *
    }
  if$
}

INTEGERS { multiresult }
FUNCTION {multi.page.check}
{ 't :=
  #0 'multiresult :=
    { multiresult not
      t empty$ not
      and
    }
    { t #1 #1 substring$
      duplicate$ "-" =
      swap$ duplicate$ "," =
      swap$ "+" =
      or or
        { #1 'multiresult := }
        { t #2 global.max$ substring$ 't := }
      if$
    }
  while$
  multiresult
}

FUNCTION {format.pages}
{ pages duplicate$ empty$
    'skip$
    { duplicate$ multi.page.check
        {
          bbl.pages swap$
          n.dashify
        }{
          bbl.page swap$
        }
      if$
      tie.or.space.prefix
      "pages" bibinfo.check
      * *
    }
  if$
}

FUNCTION {format.book.pages}
{
  pages duplicate$ empty$ 'skip$
    {
      "pages" bibinfo.check word.space bbl.pages * *
    }
  if$
}

FUNCTION {volnum.punct}
{
          ","
  word.space *
}

FUNCTION {format.journal.pages}
{ pages duplicate$ empty$ 'pop$
    { swap$ duplicate$ empty$
        { pop$ pop$ format.pages }
        { volnum.punct *
          swap$
          n.dashify
          "pages" bibinfo.check
          *
        }
      if$
    }
  if$
}

FUNCTION {format.journal.eid}
{ eid "eid" bibinfo.check
  duplicate$ empty$ 'pop$
    { swap$ duplicate$ empty$ 'skip$
        { volnum.punct * }
      if$
      swap$ *
    }
  if$
}

FUNCTION {eid.or.pages}
{
  eid empty$
    { format.journal.pages }
    { format.journal.eid }
  if$
}

FUNCTION {format.ser.vol.num}
{
  series "series" bibinfo.check output
      after.punctuation 'output.state :=
  volume field.or.null
  duplicate$ empty$ 'skip$
    {
      "volume" bibinfo.check
    }
  if$
  bolden
}

FUNCTION {format.chapter.pages}
{ chapter empty$
    {
    format.pages
    }
    { type empty$
        {
          bbl.chapter
          capitalize
        }{
          type
          capitalize
          "type" bibinfo.check
        }
      if$
      chapter tie.or.space.prefix
      "chapter" bibinfo.check
      * *
      pages empty$
        'skip$
        { ", " * format.pages * }
      if$
    }
  if$
}

FUNCTION {format.booktitle}
{
  booktitle duplicate$ "booktitle" bibinfo.check swap$
  duplicate$ empty$ 'pop$
    {
      punctuation.yes 'punctuation.state :=
      pop$ emphasize
      select.language
    }
  if$
}

FUNCTION {format.editor.in}
{
  editor "editor" format.names.ed duplicate$ empty$ 'skip$
    {
      bbl.edby
      word.space * swap$ *
    }
  if$
}

FUNCTION {output.article.booktitle}
{
  format.booktitle
      "booktitle" 'bibfield :=
  output
  bookaddress "address" bibinfo.check duplicate$ empty$ 'pop$
    {
      "address" 'bibfield :=
      output.nonnull after.punctuation 'output.state :=
    }
  if$
}

FUNCTION {format.in.ed.booktitle}
{
  format.booktitle duplicate$ empty$ 'pop$
    {
  add.doi
      word.in swap$ * output.nonnull
      bookaddress "address" bibinfo.check output
      format.number.series "series and number" bibinfo.check output
      format.bvolume output
      format.editor.in "editor" bibinfo.check output
    }
  if$
}

FUNCTION {format.in.ed.booktitle.inbook}
{
  format.booktitle duplicate$ empty$ 'pop$
    {
  add.doi
      word.in swap$ * output.nonnull
      bookaddress "address" bibinfo.check output
      format.number.series "series and number" bibinfo.check output
      format.bvolume output
      author empty$ 'skip$
        { format.editor.in "editor" bibinfo.check output }
    if$
    }
  if$
}

FUNCTION {format.thesis.type}
{ type duplicate$ empty$
    'pop$
    { swap$ pop$
      "t" change.case$ "type" bibinfo.check
    }
  if$
}

FUNCTION {format.tr.number}
{ number "number" bibinfo.check
  type duplicate$ empty$
    { pop$ bbl.techrep }
    'skip$
  if$
  "type" bibinfo.check
  swap$ duplicate$ empty$
    { pop$ "t" change.case$ }
    { tie.or.space.prefix * * }
  if$
}

FUNCTION {format.article.crossref}
{
  word.in
  " \cite{" * crossref * "}" *
}

FUNCTION {format.book.crossref}
{ volume duplicate$ empty$
    { "empty volume in " cite$ * "'s crossref of " * crossref * warning$
      pop$ word.in
    }
    { bbl.volume
      swap$ tie.or.space.prefix "volume" bibinfo.check * * bbl.of space.word *
    }
  if$
  " \cite{" * crossref * "}" *
}

FUNCTION {format.incoll.inproc.crossref}
{
  word.in
  " \cite{" * crossref * "}" *
}

FUNCTION {format.org.or.pub}
{ 't :=
  ""
  address "address" bibinfo.check
  duplicate$ empty$
    { pop$ t }
    { t duplicate$ empty$
        { pop$ }
        {
          "," word.space *
          * swap$ *
        }
      if$
    }
  if$
  *
  year duplicate$ empty$
    {
      "empty year in " cite$ *
      warning$
      pop$ ""
    }
    'skip$
  if$
  duplicate$ empty$
    { pop$ }
    {
      "year" bibinfo.check
      swap$
      duplicate$ empty$
        { pop$ }
        {
          "," *
          word.space *
          swap$ *
        }
      if$
    }
  if$
  duplicate$ empty$ 'skip$ {
    ""
    "(" * swap$ * ")" *
    after.punctuation 'output.state :=
    punctuation.space 'punctuation.state :=
  } if$
}

FUNCTION {format.publisher.address}
{ publisher "publisher" bibinfo.warn format.org.or.pub
}

FUNCTION {format.organization.address}
{ organization "organization" bibinfo.check format.org.or.pub
}

FUNCTION {format.organization.publisher.address}
{
  publisher empty$
    { format.organization.address }
    { organization "organization" bibinfo.check output
      format.publisher.address
    }
  if$
}

FUNCTION {format.school.address.output}
{
  school  "school"  bibinfo.warn
  address "address" bibinfo.check
  duplicate$ empty$ 'skip$
    {
      swap$
      duplicate$ empty$ 'skip$
        {
          ", " *
        }
      if$
      swap$
    }
  if$
  *
  output
}

FUNCTION {article}
{ output.bibitem
  format.authors
  booktitle empty$ {
      "author" output.check
    }{ output } if$
  author format.key output
  new.block.comma
  format.title
      "title" 'bibfield :=
  output
  new.block.comma
  output.article.booktitle
  crossref missing$
    {
      journal
      "journal" bibinfo.warn
      pages empty$ 'skip$ { add.doi } if$
      "journal" 'bibfield :=
      output
      format.ser.vol.num
      output
      eid.or.pages
      format.date.output.check
    }{
      format.article.crossref output.nonnull
      format.pages output
    }
  if$
  format.issn output
  pages empty$ {
  format.doi output
  } 'skip$ if$
  new.block.comma
  new.sentence.comma
  format.note output
  format.eprint output
  format.url output
  format.translation output
  fin.entry
}

FUNCTION {book}
{ output.bibitem
  author empty$
    {
    }{
      format.authors output.nonnull
      crossref missing$ { editor.check.book } 'skip$ if$
    }
  if$
  new.block.comma
  format.btitle
  add.doi
  "title" output.check
  format.edition output
  author empty$
    {
      format.editor.in output
      editor format.key output
    }
    {
    }
  if$
      format.number.series output
  crossref missing$
    {
      format.bvolume output
      new.block.comma
      format.publisher.address output
    }{
      new.block.comma
      format.book.crossref output.nonnull
      format.date.output.check
    }
  if$
  format.isbn output
      format.chapter.pages
      output
  new.block.comma
  new.sentence.comma
  format.note output
  format.eprint output
  format.url output
  fin.entry
}

FUNCTION {booklet}
{ output.bibitem
  format.authors output
  author format.key output
  new.block.comma
  format.title
  add.doi
  "title" output.check
  new.block.comma
  howpublished "howpublished" bibinfo.check output
  address "address" bibinfo.check output
  format.date.output
  format.isbn output
  format.book.pages output
  new.block.comma
  new.sentence.comma
  format.note output
  format.eprint output
  format.url output
  fin.entry
}

FUNCTION {inbook}
{ output.bibitem
  author empty$
    {
       format.editors "editor" output.check
       editor format.key output
    }{
       format.authors output.nonnull
       author format.key output
    }
  if$
  new.block.comma

  format.title output
  new.block.comma

  crossref missing$
    {
      format.in.ed.booktitle.inbook
      format.publisher.address output
      format.chapter.pages
      "chapter and pages"
      output.check
      new.block.comma
      format.edition output
      new.block.comma
    }{
      format.chapter.pages
      "chapter and pages"
      output.check
      new.block.comma
      format.book.crossref output.nonnull
      format.date.output.check
    }
  if$
  crossref missing$
    { format.isbn output }
    'skip$
  if$
  new.block.comma
  new.sentence.comma
  format.note output
  format.eprint output
  format.url output
  fin.entry
}

FUNCTION {incollection}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  new.block.comma
  format.title
  output
  new.block.comma
  crossref missing$
    {
      format.in.ed.booktitle
      format.publisher.address output
      format.edition output
      format.chapter.pages output
      format.isbn output
    }{
      format.incoll.inproc.crossref output.nonnull
      format.chapter.pages output
    }
  if$
  new.block.comma
  new.sentence.comma
  format.note output
  format.eprint output
  format.url output
  fin.entry
}

FUNCTION {inproceedings}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  new.block.comma
  format.title
  output
  new.block.comma
  crossref missing$
    {
      format.in.ed.booktitle
      format.organization.publisher.address output
      format.chapter.pages output
      format.isbn output
      format.issn output
    }{
      format.incoll.inproc.crossref output.nonnull
      format.chapter.pages output
    }
  if$
  new.block.comma
  new.sentence.comma
  format.note output
  format.eprint output
  format.url output
  fin.entry
}

FUNCTION {conference} { inproceedings }
FUNCTION {manual}
{ output.bibitem
  format.authors output
  author format.key output
  new.block.comma
  format.btitle
  add.doi
  "title" output.check
      organization "organization" bibinfo.check output
      address "address" bibinfo.check output
  format.edition output
  format.date.output
  new.block.comma
  new.sentence.comma
  format.note output
  format.eprint output
  format.url output
  fin.entry
}

FUNCTION {mastersthesis}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  new.block.comma
  format.btitle
  output
  new.block.comma
  bbl.mthesis
  format.thesis.type
  add.doi
  output.nonnull
  format.school.address.output
  format.date.output.check
  new.block.comma
  new.sentence.comma
  format.note output
  format.eprint output
  format.url output
  fin.entry
}

FUNCTION {misc}
{ output.bibitem
  format.authors output
  author format.key output
  new.block.comma
  format.title
  add.doi
  output
  new.block.comma
  howpublished "howpublished" bibinfo.check output
  format.date.output
  new.block.comma
  new.sentence.comma
  format.note output
  format.eprint output
  format.url output
  fin.entry
}

FUNCTION {phdthesis}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  new.block.comma
  format.btitle
  output
  new.block.comma
  bbl.phdthesis
  format.thesis.type
  add.doi
  output.nonnull
  format.school.address.output
  format.date.output.check
  new.block.comma
  new.sentence.comma
  format.note output
  format.eprint output
  format.url output
  fin.entry
}

FUNCTION {presentation}
{ output.bibitem
  format.authors output
  author format.key output
  new.block.comma
  format.title output
  new.block.comma
  format.organization.address "organization and address" output.check
  month "month" output.check
  year "year" output.check
  new.block.comma
  new.sentence.comma
  format.note output
  new.sentence
  type missing$ 'skip$
    {"(" type capitalize * ")" * output}
  if$
  new.block.comma format.url output
  fin.entry
}

FUNCTION {proceedings}
{ output.bibitem
  format.editors output
  editor format.key output
  new.block.comma
  format.btitle
  add.doi
  "title" output.check
      bookaddress "address" bibinfo.check output
  format.number.series output
  format.bvolume output
  format.organization.publisher.address output
  format.isbn output
  format.issn output
  new.block.comma
  new.sentence.comma
  format.note output
  format.eprint output
  format.url output
  fin.entry
}

FUNCTION {techreport}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  new.block.comma
  format.title
  add.doi
  "title" output.check
  new.block.comma
  format.tr.number
  output.nonnull
  institution "institution" bibinfo.warn
  format.org.or.pub output
  new.block.comma
  new.sentence.comma
  format.note output
  format.eprint output
  format.url output
  fin.entry
}

FUNCTION {unpublished}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  new.block.comma
  format.title
  add.doi
  "title" output.check
  format.date.output
  new.block.comma
  new.sentence.comma
  format.note "note" output.check
  format.eprint output
  format.url output
  fin.entry
}

FUNCTION {default.type} { misc }
READ
FUNCTION {sortify}
{ purify$
  "l" change.case$
}

INTEGERS { len }
FUNCTION {chop.word}
{ 's :=
  'len :=
  s #1 len substring$ =
    { s len #1 + global.max$ substring$ }
    's
  if$
}

FUNCTION {format.lab.names}
{ 's :=
  "" 't :=
  s #1
  "{vv~}{ll}"
  format.name$
  cite.name.font
  s num.names$ duplicate$
  #2 >
    { pop$
      word.space * bbl.etal
      emphasize
      *
    }{
      #2 <
        'skip$
        {
          s #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =
            {
              word.space * bbl.etal
              emphasize
              *
            }{
              bbl.and space.word *
              s #2 "{vv~}{ll}" format.name$
              cite.name.font
              *
            }
          if$
        }
      if$
    }
  if$
}

FUNCTION {author.key.label}
{ author empty$
    { key empty$
        { cite$ #1 #3 substring$ }
        'key
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {author.editor.key.label}
{ author empty$
    { editor empty$
        { key empty$
            { cite$ #1 #3 substring$ }
            'key
          if$
        }
        { editor format.lab.names }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {editor.key.label}
{ editor empty$
    { key empty$
        { cite$ #1 #3 substring$ }
        'key
      if$
    }
    { editor format.lab.names }
  if$
}

FUNCTION {calc.short.authors}
{ type$ "book" =
  type$ "inbook" =
  or
    'author.editor.key.label
    { type$ "proceedings" =
        'editor.key.label
        'author.key.label
      if$
    }
  if$
  'short.list :=
}

FUNCTION {calc.label}
{ calc.short.authors
  short.list
  "("
  *
  year duplicate$ empty$
    {
      pop$ ""
    }{
      purify$ #-1 #4 substring$
    }
  if$
  *
  'label :=
}

FUNCTION {sort.format.names}
{ 's :=
  #1 'nameptr :=
  ""
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    { s nameptr
      "{ll{ }}{  ff{ }}{  jj{ }}"
      format.name$ 't :=
      nameptr #1 >
        {
          "   "  *
          namesleft #1 = t "others" = and
            { "zzzzz" * }
            {
              t sortify *
            }
          if$
        }
        { t sortify * }
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}

FUNCTION {sort.format.title}
{ 't :=
  "A " #2
    "An " #3
      "The " #4 t chop.word
    chop.word
  chop.word
  sortify
  #1 global.max$ substring$
}

FUNCTION {author.sort}
{ author empty$
    { key empty$
        { "to sort, need author or key in " cite$ * warning$
          ""
        }
        { key sortify }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {author.editor.sort}
{ author empty$
    { editor empty$
        { key empty$
            { "to sort, need author, editor, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { editor sort.format.names }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {editor.sort}
{ editor empty$
    { key empty$
        { "to sort, need editor or key in " cite$ * warning$
          ""
        }
        { key sortify }
      if$
    }
    { editor sort.format.names }
  if$
}

FUNCTION {presort}
{ calc.label
  label sortify
  "    "
  *
  type$ "book" =
  type$ "inbook" =
  or
    'author.editor.sort
    { type$ "proceedings" =
        'editor.sort
        'author.sort
      if$
    }
  if$
  #1 entry.max$ substring$
  'sort.label :=
  sort.label
  *
  "    "
  *
  title field.or.null
  sort.format.title
  *
  #1 entry.max$ substring$
  'sort.key$ :=
}

ITERATE {presort}
SORT
STRINGS { last.label next.extra }
INTEGERS { last.extra.num number.label }
FUNCTION {initialize.extra.label.stuff}
{ #0 int.to.chr$ 'last.label :=
  "" 'next.extra :=
  #0 'last.extra.num :=
  #0 'number.label :=
}

FUNCTION {forward.pass}
{ last.label label =
    { last.extra.num #1 + 'last.extra.num :=
      last.extra.num int.to.chr$ 'extra.label :=
    }
    { "a" chr.to.int$ 'last.extra.num :=
      "" 'extra.label :=
      label 'last.label :=
    }
  if$
  number.label #1 + 'number.label :=
}

FUNCTION {reverse.pass}
{ next.extra "b" =
    { "a" 'extra.label := }
    'skip$
  if$
  extra.label 'next.extra :=
  extra.label
  duplicate$ empty$
    'skip$
    { "{\natexlab{" swap$ * "}}" * }
  if$
  'extra.label :=
  label extra.label * 'label :=
}

EXECUTE {initialize.extra.label.stuff}
ITERATE {forward.pass}
REVERSE {reverse.pass}
FUNCTION {bib.sort.order}
{ sort.label
  "    "
  *
  year
  field.or.null sortify
  *
  "    "
  *
  title field.or.null
  sort.format.title
  *
  #1 entry.max$ substring$
  'sort.key$ :=
}

ITERATE {bib.sort.order}
SORT
FUNCTION {init.bib.eprint}
{
    "\texttt{"
  pop$
  "\providecommand \url  [0]{\begingroup\@sanitize \@url }%" write$ newline$
  "\providecommand \@url [1]{\endgroup\@href {#1}{" "}}%" bbl.url.prefix swap$ * * write$ newline$
  "\providecommand " " [0]{URL }%" bbl.url.prefix swap$ * * write$ newline$
  eprint.command "\providecommand " swap$ * "[0]{\href }%" * write$ newline$
}

FUNCTION {init.bib.doi}
{
  "\@ifxundefined \urlstyle {%"  write$ newline$
  "  \providecommand \doi [1]{doi:\discretionary{}{}{}#1}%"  write$ newline$
  "}{%"  write$ newline$
  "  \providecommand \doi [0]{doi:\discretionary{}{}{}\begingroup \urlstyle{rm}\Url }%"
  write$ newline$
  "}%"  write$ newline$
  "\providecommand \doibase [0]{" doi.base * "}%" * write$ newline$
  doi.command.href "\providecommand " swap$ * "[1]{\href{\doibase#1}}%" * write$ newline$
}

FUNCTION {init.bib.hypertex}
{
  "\providecommand\href[0]{\@sanitize\@href}%" write$ newline$
  "\providecommand\@href[1]{\endgroup\@@startlink{#1}\endgroup\@@href}%" write$ newline$
  "\providecommand\@@href[1]{#1\@@endlink}%" write$ newline$
  "\providecommand \@sanitize [0]{\begingroup\catcode`\&12\catcode`\#12\relax}%" write$ newline$
  "\@ifxundefined \pdfoutput {\@firstoftwo}{%" write$ newline$
  " \@ifnum{\z@=\pdfoutput}{\@firstoftwo}{\@secondoftwo}%" write$ newline$
  "}{%" write$ newline$
  " \providecommand\@@startlink[1]{\leavevmode\special{html:<a href=" quote$ * "#1" * quote$ * ">}}%" * write$ newline$
  " \providecommand\@@endlink[0]{\special{html:</a>}}%" write$ newline$
  "}{%" write$ newline$
  " \providecommand\@@startlink[1]{%" write$ newline$
  "  \leavevmode" write$ newline$
  "  \pdfstartlink" write$ newline$
  "   attr{/Border[0 0 1 ]/H/I/C[0 1 1]}%" write$ newline$
  "   user{/Subtype/Link/A<</Type/Action/S/URI/URI(#1)>>}%" write$ newline$
  "  \relax" write$ newline$
  " }%" write$ newline$
  " \providecommand\@@endlink[0]{\pdfendlink}%" write$ newline$
  "}%" write$ newline$
}

FUNCTION {init.bib.namefont}
{
  "\providecommand \bibnamefont  [1]{#1}%"  write$ newline$
  "\providecommand \bibfnamefont [1]{#1}%" write$ newline$
  "\providecommand \citenamefont [1]{#1}%"  write$ newline$
}

FUNCTION {init.bib.quote}
{
  "\providecommand " bbl.enquote * " [1]{" *
  "``" "''"
  "#1" swap$ "}%" * * * * write$ newline$
}

FUNCTION {init.bib.ay}
{
  "\providecommand \natexlab [1]{#1}%"
  write$ newline$
}

FUNCTION {init.bib.bibinfo}
{
  bibinfo.command  "\providecommand " swap$ * " [0]{\@secondoftwo}%" * write$ newline$
  bibfield.command "\providecommand " swap$ * " [0]{\@secondoftwo}%" * write$ newline$
}

FUNCTION {init.bib.lang}
{
  "\providecommand \selectlanguage [0]{\@gobble}%" write$ newline$
}

FUNCTION {init.bib.endbibitem}
{
  "\providecommand " bbl.open * "[0]{}%" *           write$ newline$
  "\providecommand \bibitemStop [0]{}%"               write$ newline$
  "\providecommand \bibitemNoStop [0]{.\EOS\space}%"  write$ newline$
  "\providecommand \EOS [0]{\spacefactor3000\relax}%"   write$ newline$
}

FUNCTION {init.bib.translation}
{
  "\providecommand \translation [1]{[#1]}%" write$ newline$
}

FUNCTION {warn.bib}
{
}

FUNCTION {init.bib}
{
  warn.bib
  "\makeatletter" write$ newline$
  "\providecommand \@ifxundefined [1]{%"     write$ newline$
  " \ifx #1\undefined \expandafter \@firstoftwo" write$ newline$
  " \else \expandafter \@secondoftwo"      write$ newline$
  "\fi"                                    write$ newline$
  "}%"                                     write$ newline$
  "\providecommand \@ifnum [1]{%"          write$ newline$
  " \ifnum #1\expandafter \@firstoftwo"    write$ newline$
  " \else \expandafter \@secondoftwo"      write$ newline$
  "\fi"                                    write$ newline$
  "}%"                                     write$ newline$
  init.bib.ay
  init.bib.quote
  init.bib.namefont
  init.bib.hypertex
  init.bib.eprint
  init.bib.doi
  init.bib.lang
  init.bib.bibinfo
  init.bib.translation
  init.bib.endbibitem
  "\providecommand " bbl.shut * " [1]{\csname bibitem#1\endcsname}%" * write$ newline$
  "%</preamble>" write$
}

FUNCTION {begin.bib}
{
  id.bst duplicate$ top$ "%" swap$ * write$ newline$
  preamble$ empty$
    'skip$
    { preamble$ write$ newline$ }
  if$
  "\begin{thebibliography}{"
  number.label int.to.str$
  * "}%" *
  write$ newline$
  init.bib
}

EXECUTE {begin.bib}
EXECUTE {init.state.consts}
ITERATE {call.type$}
FUNCTION {end.bib}
{ newline$
  "\end{thebibliography}%"
  write$ newline$
}

EXECUTE {end.bib}
%% End of customized bst file
%%
%% End of file `aipauth4-1long.bst'.
